데이터를 먼저 정의하기

Arraylist-> Vector의 업그레이드 버전
왠만하면 arraylist를 사용하는 것이 좋다.

상황에 따라서 배열과 arraylist 를 선택
객체 배열을 쓰면 시스템이 다소 무거워짐

배열의 단점-미리 공간을 만들어둠
arraylist-10개씩 늘려감

긴급공문-코로나

동명이인이 있을때 선택을 하게함 (다른정보로 검색을 하게함)
프라이머리 키(주키)
객체 배열을 한개 더 만들어서 프라이머리 키로 연결함
정보배열/점수배열
db와의 연결

추상 클래스-상속을 해서 완성을 시켜줘야사용가능
인터페이스- 구현을 해줘야지 사용가능(다 완성이 안되있다)

------------------------추상클래스(단독 사용 불가)-------------------------------------
--일부만 완성이 안되있는 클래스(추상메소드를 포함하고 있다)
메소드 호출은 리턴타입이 없다.
추상메소드는 리턴타입,매개변수는 있어도 구현부(중괄호)가 없다. 
일반메소드에서 추상메소드를 호출할수 있다. 

추상클래스도 생성자가 있어야함

완성되지 않을시 단독으로 객체선언 불가

상속 받은 클래스에서도 완성을 못한경우 그 클래스도 추상클래스가 된다.

만드는 이유: 일부만 제작하고 사용자가 완성시키게 하기위해 

꼭 필요하지만 자손마다 다르게 구현되야 하는경우
ex)비디오 플레이어와 음악플레이어의 플레이버튼
(기능은 똑같지만 구현해야하는 내용이 다르다)

필수 기능추가를 빠뜨리는 경우를 방지, 메소드명을(비슷한 기능의) 통일하는 효과,
업무분담이 있는 경우

다형성의 경우 자손의 메소드를 사용할경우 형변환필요하지만
추상클래스로 해놓으면 형변환없이 바로 자손의 메소드 실행가능(조상에 추상화된 메소드가 있으니까)
조상의 메소드를 호출하는 것처럼 보이지만 실제로는 각 자손들에 완성된 메소드를 호출

추상클래스 또한 Object클래스를 상속받는다.

완성시키는 방법-  오버라이딩으로 추상메소드 재정의




----------------------------인터페이스(껍데기)----------------------------------

추상클래스와 비슷한 개념(추상클래스보다 더 추상적)

기본설계도- 구현된 부분이 없다.

표준 구조를 제시한다.(클래스 작성에 도움을 줄 목적으로 사용)-메소드명을 통일되게

추상메소드와 상수만이 들어갈수 있다.

객체 생성불가

그외에는 추상클래스의 성질이 적용

Object클래스를 상속받지 않는다.(최고조상이 없다.)

클래스 대신에 interface를 붙임
변수에는 public static final을 붙여야되고
메소드는 (public) abstract을 붙여야 된다
단, 안붙일 경우 자동으로 붙여줌(변수로 선언해도 상수로 됨)

다중상속이 가능하다.(최고조상의 상속을 안받기때문)
인터페이스로 상속을 받을수도 있다.
상속도 받고 구현도 할수있음(동시에)

인터페이스 상속방법- 클래스 이름 implements(뜻:구현) 인터페이스 이름
인터페이스의 추상메소드를 다 완성해야 사용가능
상속했으나 구현을 미완성 했을경우 추상 클래스로 정의됨



인터페이스 타입 변수로 구현 클래스 객체를 선언할수 있다.(다형성)
-조상과 자손의 개념으로 사용가능
-인터페이스를 매개변수로 보낼수 있다.(구현하고 있는 클래스들을 보낼수 있다.)
-전혀 상관이 없는것들도 구현을 하게 함으로써 묶을수도 있다.
(아예  비어있는 인터페이스를 선언하고 거기에 집어넣음)
-인터페이스를 리턴타입으로도 쓸수있다.
-캡슐화
 
매개변수로 인터페이스를 가져오면 원래의 형태로 형변환을 해야 사용가능

공통 조상에서 소수의 그룹핑을 할때

명령어를 통일





복습! 
java 
html+css+js(스크립트)

jsp
oracle

spring
node.js





